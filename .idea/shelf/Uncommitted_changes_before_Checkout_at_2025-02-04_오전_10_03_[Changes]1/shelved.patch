Index: app/src/main/java/com/example/frume/fragment/user_fragment/user_payment/UserPaymentScreenFragment.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.example.frume.fragment.user_fragment.user_payment\r\n\r\n\r\nimport android.os.Bundle\r\nimport android.text.Editable\r\nimport android.text.TextWatcher\r\nimport android.util.Log\r\nimport android.view.LayoutInflater\r\nimport android.view.View\r\nimport android.view.ViewGroup\r\nimport android.widget.ArrayAdapter\r\nimport android.widget.RadioButton\r\nimport androidx.databinding.DataBindingUtil\r\nimport androidx.fragment.app.Fragment\r\nimport androidx.navigation.fragment.findNavController\r\nimport androidx.navigation.fragment.navArgs\r\nimport com.example.frume.R\r\nimport com.example.frume.activity.HomeActivity\r\nimport com.example.frume.databinding.FragmentUserPaymentScreenBinding\r\nimport com.example.frume.model.CartProductModel\r\nimport com.example.frume.model.DeliveryAddressModel\r\nimport com.example.frume.model.DeliveryModel\r\nimport com.example.frume.model.OrderModel\r\nimport com.example.frume.model.OrderProductModel\r\nimport com.example.frume.model.ProductModel\r\nimport com.example.frume.model.UserModel\r\nimport com.example.frume.service.CartProductService\r\nimport com.example.frume.service.DeliveryService\r\nimport com.example.frume.service.OrderProductService\r\nimport com.example.frume.service.OrderService\r\nimport com.example.frume.service.ProductService\r\nimport com.example.frume.service.UserDeliveryAddressService\r\nimport com.example.frume.service.UserService\r\nimport com.example.frume.util.DeliveryOption\r\nimport com.example.frume.util.OrderPaymentOption\r\nimport com.example.frume.util.convertThreeDigitComma\r\nimport com.google.firebase.Timestamp\r\nimport kotlinx.coroutines.CoroutineScope\r\nimport kotlinx.coroutines.Dispatchers\r\nimport kotlinx.coroutines.TimeoutCancellationException\r\nimport kotlinx.coroutines.async\r\nimport kotlinx.coroutines.delay\r\nimport kotlinx.coroutines.launch\r\nimport kotlinx.coroutines.withContext\r\nimport kotlinx.coroutines.withTimeout\r\nimport kotlinx.coroutines.withTimeoutOrNull\r\nimport java.text.SimpleDateFormat\r\nimport java.util.Calendar\r\nimport java.util.Locale\r\nimport java.util.TimeZone\r\n\r\n// 결제 화면\r\nclass UserPaymentScreenFragment : Fragment() {\r\n\r\n    private var _binding: FragmentUserPaymentScreenBinding? = null\r\n    private val binding get() = _binding!!\r\n    private val args: UserPaymentScreenFragmentArgs by navArgs()\r\n    lateinit var homeActivity: HomeActivity\r\n    private var paymentOptionState = OrderPaymentOption.ORDER_PAYMENT_OPTION_ACCOUNT\r\n\r\n    // 스크롤 위치 저장 변수\r\n    private var scrollPotition = 0\r\n\r\n    // 배송지를 담을 변수 처음엔 기본배송지를 담을 예정\r\n    var deliveryAddressSpot: DeliveryAddressModel? = null\r\n\r\n    // 주문자 정보 담을 변수\r\n    var userModel: UserModel? = null\r\n\r\n\r\n    override fun onCreateView(\r\n        inflater: LayoutInflater,\r\n        container: ViewGroup?,\r\n        savedInstanceState: Bundle?\r\n    ): View {\r\n        _binding = DataBindingUtil.inflate(\r\n            inflater,\r\n            R.layout.fragment_user_payment_screen,\r\n            container,\r\n            false\r\n\r\n        )\r\n        homeActivity = activity as HomeActivity\r\n\r\n        // 툴바 뒤로가기\r\n        onClickToolbarNavigationBtn()\r\n\r\n        // 카드 선택 -> 카드사 선택 드롭 다운\r\n\r\n        setupPaymentMethodButtons()\r\n        setupCheckBoxListeners()\r\n\r\n        // 배송지 정보를 받아오는 메서드 호출\r\n        getReceiverData()\r\n        // 배송지 정보를 토대로 배송지 정보를 세팅하는 메서드 호출\r\n        settingReceiverInfo()\r\n        // 보유 적립금 표시 메서드 호출\r\n        settingViewMyReward()\r\n        // 상품 가격 표시 메서드 호출\r\n        settingViewProductsPrice()\r\n        // 배송비 표시 메서드 호출\r\n        settingViewDeliverCost()\r\n        // 적립금 사용 editText 설정 메서드 호출\r\n        settingTextInputLayoutUserPaymentSaving()\r\n        // 적립금 전액사용 체크 리스너 메서드 호출\r\n        checkUseRewardAll()\r\n        // 총 결제 금액 표시 메서드 호출\r\n        settingViewTotalCost()\r\n        // 주문 완료 버튼 클릭 시 처리 메서드 호출\r\n        onClickButtonButtonUserCartOrder()\r\n\r\n        return binding.root\r\n    }\r\n\r\n\r\n    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {\r\n        super.onViewCreated(view, savedInstanceState)\r\n        onClickToolbarNavigationBtn()  // 툴바 내비게이션 버튼 클릭 리스너 설정\r\n        onClickPaymentDeliverySpotChange()  // 배송지 변경 버튼 클릭 리스너 설정\r\n        setupDeliveryWayRadioButtons()  // 배송 방식 라디오 버튼 설정\r\n        // 주문자 정보 가져와 view에 적용하는 메서드 호출\r\n        gettingUserInfo()\r\n        onClickTextView()\r\n        setAccountAndCard(1)\r\n    }\r\n\r\n    private fun onClickTextView() {\r\n        binding.scrollView.post {\r\n            binding.scrollView.scrollTo(0, scrollPotition)\r\n        }\r\n        // 배송 안내\r\n        binding.textViewUserPaymentGuide1.setOnClickListener {\r\n            scrollPotition = binding.scrollView.scrollY\r\n            val action = UserPaymentScreenFragmentDirections.actionUserPaymentScreenToUserPaymentWebView(0)\r\n            findNavController().navigate(action)\r\n        }\r\n        // 교환 안내\r\n        binding.textViewUserPaymentGuide2.setOnClickListener {\r\n            scrollPotition = binding.scrollView.scrollY\r\n            val action = UserPaymentScreenFragmentDirections.actionUserPaymentScreenToUserPaymentWebView(1)\r\n            findNavController().navigate(action)\r\n        }\r\n    }\r\n\r\n    // 툴바 내비게이션 버튼 클릭 리스너\r\n    private fun onClickToolbarNavigationBtn() {\r\n        binding.toolbarUserPaymentScreen.setNavigationOnClickListener {\r\n            // 내비게이션 아이콘을 클릭하면 이전 화면으로 돌아감\r\n            findNavController().navigateUp()\r\n        }\r\n    }\r\n\r\n    // 카드 드롭다운 리스너\r\n    private fun setupPaymentCardDropdown() {\r\n\r\n        val autoCompletePaymentCardTextView = binding.autoCompleteTextViewUserPaymentCard\r\n\r\n        // 드롭다운 데이터 정의\r\n        val cardTypes = listOf(\"선택\", \"삼성\", \"신한\", \"국민\", \"롯데\", \"현대\", \"하나\", \"NH\", \"우리\", \"카카오뱅크\", \"비씨\")\r\n\r\n        // ArrayAdapter 생성 (autoCompletePaymentCardTextView에 데이터 연결)\r\n        val adapterCardType = ArrayAdapter(\r\n            homeActivity,\r\n            android.R.layout.simple_dropdown_item_1line,\r\n            cardTypes\r\n        )\r\n\r\n        // autoCompletePaymentCardTextView에 연결\r\n        autoCompletePaymentCardTextView.setAdapter(adapterCardType)\r\n\r\n        // autoCompletePaymentCardTextView 항목 선택 이벤트 리스너 설정\r\n        autoCompletePaymentCardTextView.setOnItemClickListener { parent, view, position, id ->\r\n            val selectedCardType = parent.getItemAtPosition(position).toString()\r\n        }\r\n    }\r\n\r\n    private fun setAccountAndCard(type: Int) {\r\n        when (type) {\r\n            1 -> {\r\n                with(binding) {\r\n                    textInputLayoutUserPaymentCard.visibility = View.VISIBLE\r\n                    textViewUserPaymentCard.visibility = View.VISIBLE\r\n                    textViewUserPaymentStar.visibility = View.VISIBLE\r\n\r\n                    textViewUserPaymentCard.text = \"계좌 번호\"\r\n                    textInputLayoutUserPaymentCard.hint = \"계좌 번호\"\r\n                    textInputLayoutUserPaymentCard.editText?.setText(\"푸르미(멋사) 20250106-20250206\")\r\n                    textInputLayoutUserPaymentCard.isEnabled = false\r\n                }\r\n            }\r\n\r\n            2 -> {\r\n                with(binding) {\r\n                    textInputLayoutUserPaymentCard.visibility = View.VISIBLE\r\n                    textViewUserPaymentCard.visibility = View.VISIBLE\r\n                    textViewUserPaymentStar.visibility = View.VISIBLE\r\n\r\n                    textViewUserPaymentCard.text = \"카드 선택\"\r\n                    textInputLayoutUserPaymentCard.hint = \"카드\"\r\n                    textInputLayoutUserPaymentCard.editText?.setText(\"선택\")\r\n                    textInputLayoutUserPaymentCard.isEnabled = true\r\n                    setupPaymentCardDropdown()\r\n                }\r\n            }\r\n\r\n            else -> {\r\n                with(binding) {\r\n                    textInputLayoutUserPaymentCard.visibility = View.GONE\r\n                    textViewUserPaymentCard.visibility = View.GONE\r\n                    textViewUserPaymentStar.visibility = View.GONE\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // 결제 방식 버튼을 단일 선택만 가능하도록 하는 메서드\r\n    private fun setupPaymentMethodButtons() {\r\n\r\n        // 버튼을 리스트로 묶어 관리\r\n        val buttons = listOf(\r\n            binding.buttonUserPaymentPaymentMethodAccount,\r\n            binding.buttonUserPaymentPaymentMethodCard,\r\n            binding.buttonUserPaymentPaymentMethodKakaoPay,\r\n            binding.buttonUserPaymentPaymentMethodNaverPay\r\n        )\r\n\r\n        // 각 버튼에 대한 클릭 이벤트\r\n        buttons.forEach { button ->\r\n            button.setOnClickListener {\r\n                // 모든 버튼을 비활성화 스타일(AppButtonCancel)로 변경\r\n                buttons.forEach { btn ->\r\n                    btn.setBackgroundResource(R.drawable.background_gray100) // 비활성화 배경\r\n                    //btn.setTextAppearance(R.style.AppButtonCancel) // 비활성화 텍스트 스타일\r\n                }\r\n\r\n                // 클릭된 버튼을 활성화 스타일(CustomButtonStyle)로 변경\r\n                button.setBackgroundResource(R.drawable.background_green100) // 활성화 배경\r\n                //button.setTextAppearance(R.style.CustomButtonStyle) // 활성화 텍스트 스타일\r\n\r\n\r\n                // 각 버튼에 따른 추가 동작 처리\r\n                when (button.id) {\r\n                    R.id.buttonUserPaymentPaymentMethodAccount -> {\r\n                        // 계좌이체 버튼 선택 시 동작\r\n                        setAccountAndCard(1)\r\n                        paymentOptionState = OrderPaymentOption.ORDER_PAYMENT_OPTION_ACCOUNT\r\n                    }\r\n\r\n                    R.id.buttonUserPaymentPaymentMethodCard -> {\r\n                        // 신용카드 버튼 선택 시 동작\r\n                        setAccountAndCard(2)\r\n                        paymentOptionState = OrderPaymentOption.ORDER_PAYMENT_OPTION_CARD\r\n\r\n                    }\r\n\r\n                    R.id.buttonUserPaymentPaymentMethodKakaoPay -> {\r\n                        // 카카오페이 버튼 선택 시 동작\r\n                        setAccountAndCard(3)\r\n                        paymentOptionState = OrderPaymentOption.ORDER_PAYMENT_OPTION_KAKAO_PAY\r\n\r\n                    }\r\n\r\n                    R.id.buttonUserPaymentPaymentMethodNaverPay -> {\r\n                        // 네이버페이 버튼 선택 시 동작\r\n                        setAccountAndCard(4)\r\n                        paymentOptionState = OrderPaymentOption.ORDER_PAYMENT_OPTION_NAVER_PAY\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private fun setupCheckBoxListeners() {\r\n        val topCheckBox = binding.checkboxUserPaymentAgreeAll\r\n        val otherCheckBoxes = listOf(\r\n            binding.checkboxUserPaymentAgree1,\r\n            binding.checkboxUserPaymentAgree2\r\n        )\r\n        val orderButton = binding.buttonUserCartOrder\r\n\r\n        // 최상단 체크박스 상태 변경 시 다른 체크박스 모두 변경\r\n        topCheckBox.setOnCheckedChangeListener { _, isChecked ->\r\n            otherCheckBoxes.forEach { it.isChecked = isChecked }\r\n        }\r\n\r\n        // 하위 체크박스 상태 변경 시 최상단 체크박스 상태 업데이트\r\n        otherCheckBoxes.forEach { checkBox ->\r\n            checkBox.setOnCheckedChangeListener { _, _ ->\r\n                // 모든 하위 체크박스가 선택된 경우만 최상단 체크박스를 선택\r\n                topCheckBox.isChecked = otherCheckBoxes.all { it.isChecked }\r\n                updateOrderButtonState(orderButton, otherCheckBoxes)\r\n            }\r\n        }\r\n    }\r\n\r\n    // 결제 버튼 활성화\r\n    private fun updateOrderButtonState(button: View, checkBoxes: List<View>) {\r\n        // 모든 체크박스가 선택되었을 때만 버튼 활성화\r\n        button.isEnabled =\r\n            checkBoxes.all { (it as? androidx.appcompat.widget.AppCompatCheckBox)?.isChecked == true }\r\n    }\r\n\r\n\r\n    // 배송지 변경 아이콘 클릭 시 UserAddressManageFragment로 이동하는 메서드\r\n    private fun onClickPaymentDeliverySpotChange() {\r\n        binding.imageViewUserPaymentAddressModify.setOnClickListener {\r\n            // 배송지 수정 버튼 클릭 시, 배송지 관리 화면으로 이동\r\n            val action =\r\n                UserPaymentScreenFragmentDirections.actionUserPaymentScreenToUserCartChoiceDeliverAddress(\r\n                    args.fromWhere,\r\n                    args.productDocIdDirectPurchase,\r\n                    args.dueDateDirectPurchase,\r\n                    args.deliverySubscribeStateDirectPurchase,\r\n                    args.productCountDirectPurchase\r\n                )\r\n            findNavController().navigate(action)\r\n        }\r\n    }\r\n\r\n    // 라디오 버튼 설정 및 선택 처리\r\n    private fun setupDeliveryWayRadioButtons() {\r\n        // 기본적으로 '문 앞 배송'이 선택된 상태로 설정\r\n        binding.buttonUserPaymentDeliveryMethodDoor.setBackgroundResource(R.drawable.background_green100)\r\n\r\n        // 각 라디오 버튼에 클릭 리스너를 설정하여 버튼 선택 상태를 처리\r\n        binding.buttonUserPaymentDeliveryMethodDoor.setOnClickListener {\r\n            // '문 앞 배송' 버튼 클릭 시 선택된 상태로 처리\r\n            toggleButtonSelection(binding.buttonUserPaymentDeliveryMethodDoor)\r\n        }\r\n        binding.buttonUserPaymentDeliveryMethodBox.setOnClickListener {\r\n            // '택배함' 버튼 클릭 시 선택된 상태로 처리\r\n            toggleButtonSelection(binding.buttonUserPaymentDeliveryMethodBox)\r\n        }\r\n        binding.buttonUserPaymentDeliveryMethodOffice.setOnClickListener {\r\n            // '경비실' 버튼 클릭 시 선택된 상태로 처리\r\n            toggleButtonSelection(binding.buttonUserPaymentDeliveryMethodOffice)\r\n        }\r\n    }\r\n\r\n    // 선택된 버튼의 배경을 변경하고 나머지 버튼들은 기본 배경으로 설정\r\n    private fun toggleButtonSelection(selectedButton: RadioButton) {\r\n        // 모든 버튼을 기본 배경으로 리셋\r\n        listOf(\r\n            binding.buttonUserPaymentDeliveryMethodDoor,\r\n            binding.buttonUserPaymentDeliveryMethodBox,\r\n            binding.buttonUserPaymentDeliveryMethodOffice\r\n        ).forEach { button ->\r\n            // 모든 버튼에 대해 기본 배경을 설정 (회색 배경)\r\n            button.setBackgroundResource(R.drawable.background_gray100)\r\n        }\r\n\r\n        // 선택된 버튼에만 초록색 배경을 적용\r\n        selectedButton.setBackgroundResource(R.drawable.background_green100)\r\n    }\r\n\r\n    // 주문자 정보 가져와 view에 적용하는 메서드\r\n    fun gettingUserInfo() {\r\n        CoroutineScope(Dispatchers.Main).launch {\r\n            val work1 = async(Dispatchers.IO) {\r\n                UserService.getUserInfo(homeActivity.loginUserDocumentId)\r\n            }\r\n\r\n            val timeoutResult = withTimeoutOrNull(2000) {  // 2초 동안 대기\r\n                while (userModel == null) {\r\n                    userModel = work1.await().getOrNull(0)\r\n                    delay(100)  // 너무 빠른 반복을 방지\r\n                }\r\n                true  // 성공적으로 값을 가져온 경우\r\n            }\r\n\r\n            if (timeoutResult == null) {\r\n                // 2초 내에 userModel을 가져오지 못한 경우 예외 처리\r\n                binding.apply {\r\n                    textViewUserPaymentUserName.text = \"주문자 정보를 불러오지 못했습니다.\"\r\n                    textViewPaymentUserPhoneNumber.text = \"주문자 정보를 불러오지 못했습니다.\"\r\n                }\r\n            } else {\r\n                // 정상적으로 userModel이 설정된 경우 UI 업데이트\r\n                binding.apply {\r\n                    textViewUserPaymentUserName.text = \"주문자 이름 : ${userModel?.customerUserName}\"\r\n                    textViewPaymentUserPhoneNumber.text =\r\n                        \"번호 : ${userModel?.customerUserPhoneNumber}\"\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // arg 값에 따라 배송지를 가져와 spot에 넣어준다. args == null -> 기본 배송지\r\n    // 배송지를 유저정보에서 가져오지 않고, 배송지 DB에서 기본배송지를 가져오는 것으로 수정 hj 받는사람 이름도 DeliveryAddres Model 에 추가함\r\n    private fun getReceiverData() {\r\n        // 기본 배송지를 가져온다\r\n        if (args.deliveryAddressDocId == null) {\r\n            Log.d(\"test100\", \"args.deliveryAddressDocId == null \")\r\n            CoroutineScope(Dispatchers.Main).launch {\r\n                val work1 = async(Dispatchers.IO) {\r\n                    UserDeliveryAddressService.gettingDefaultDeliveryAddress(homeActivity.loginUserDocumentId)\r\n                }\r\n                deliveryAddressSpot = work1.await()\r\n            }\r\n        } else {\r\n            // 선택된 배송지를 가져온다\r\n            Log.d(\"test100\", \"not None -> args.deliveryAddressDocId: ${args.deliveryAddressDocId}\")\r\n            CoroutineScope(Dispatchers.Main).launch {\r\n                val work2 = async(Dispatchers.IO) {\r\n                    UserDeliveryAddressService.gettingSelectedDeliveryAddress(args.deliveryAddressDocId!!)\r\n                }\r\n                deliveryAddressSpot = work2.await()\r\n            }\r\n        }\r\n    }\r\n\r\n    // 아마 mvvm liveData쓰면 코드 바뀔듯\r\n    // 배송지 정보를 토대로 배송지 정보를 입력한다.\r\n    private fun settingReceiverInfo() {\r\n        binding.apply {\r\n            // CoroutineScope 사용\r\n            CoroutineScope(Dispatchers.Main).launch {\r\n                try {\r\n                    // 배송지 정보가 null이 아니거나 값이 설정될 때까지 반복 (2초 제한)\r\n                    withTimeout(2000) {  // 2000ms = 2초\r\n                        while (deliveryAddressSpot == null) {\r\n                            delay(500)  // 0.5초마다 확인\r\n                        }\r\n                    }\r\n\r\n                    // 배송지 정보가 null이 아니면 UI 업데이트\r\n                    deliveryAddressSpot?.let {\r\n                        val deliveryAddressName = it.deliveryAddressName\r\n                        val receiverName = it.deliveryAddressReceiverName\r\n                        val basicAddress = it.deliveryAddressBasicAddress\r\n                        val detailAddress = it.deliveryAddressDetailAddress\r\n                        val phoneNumber = it.deliveryAddressPhoneNumber\r\n\r\n                        // UI에 배송지 정보 입력\r\n                        // 배송지명\r\n                        viewUserPaymentAddressModifyAddressName.text = deliveryAddressName\r\n                        // 받는사람 이름\r\n                        viewUserPaymentAddressModifyUserName.text = receiverName\r\n                        // 주소\r\n                        viewUserPaymentAddressModifyUserAddress.text =\r\n                            \"${basicAddress}  ${detailAddress}\"\r\n                        // 받는사람 전화번호\r\n                        viewUserPaymentAddressModifyUserPhoneNumber.text = phoneNumber\r\n                    }\r\n                } catch (e: TimeoutCancellationException) {\r\n                    // 2초 이내에 배송지 정보가 로드되지 않으면 타임아웃 처리\r\n                    // 여기서 타임아웃 후 처리를 할 수 있음 (예: 로딩 실패 메시지 표시)\r\n                    viewUserPaymentAddressModifyAddressName.text = \"배송지 로드 실패\"\r\n                    viewUserPaymentAddressModifyUserName.text = \"배송지 로드 실패\"\r\n                    viewUserPaymentAddressModifyUserAddress.text = \"배송지 로드 실패\"\r\n                    viewUserPaymentAddressModifyUserPhoneNumber.text = \"배송지 로드 실패\"\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // 기본 배송지로 설정이 돼 있다면\r\n    fun changeBasicDeliverAddress() {\r\n        CoroutineScope(Dispatchers.Main).launch {\r\n\r\n            // 현재 기본배송지를 일반 배송지로 바꾼다.\r\n            val work1 = async(Dispatchers.IO) {\r\n                UserDeliveryAddressService.changeDefaultStateToFalse(\r\n                    homeActivity.loginUserDocumentId,\r\n                    deliveryAddressSpot!!.deliveryAddressDocId\r\n                )\r\n            }\r\n            work1.join()\r\n\r\n            // 현재 설정된 배송지를 기본 배송지로 변경한다.\r\n            val work2 = async(Dispatchers.IO) {\r\n                UserDeliveryAddressService.changeDefaultStateToTrue(\r\n                    homeActivity.loginUserDocumentId,\r\n                    deliveryAddressSpot!!.deliveryAddressDocId\r\n                )\r\n            }\r\n            work2.join()\r\n        }\r\n\r\n    }\r\n\r\n    // 적립금 전액 사용 체크\r\n    fun checkUseRewardAll() {\r\n        CoroutineScope(Dispatchers.Main).launch {\r\n            while (userModel == null) {\r\n                delay(500) // 500ms 대기 후 다시 확인\r\n            }\r\n            val userReward = userModel?.customerUserReward ?: 0\r\n\r\n            binding.checkboxUserPaymentUseSavingAll.setOnClickListener {\r\n                binding.textInputLayoutUserPaymentSaving.editText?.setText(\r\n                    if (binding.checkboxUserPaymentUseSavingAll.isChecked) userReward.toString() else \"0\"\r\n                )\r\n                // 적립금 사용액 표시 메서드 호출\r\n                settingViewReward()\r\n                // 총 결제 금액 표시\r\n                settingViewTotalCost()\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    // 적립금 사용 editText 설정\r\n    fun settingTextInputLayoutUserPaymentSaving() {\r\n        binding.apply {\r\n            textInputLayoutUserPaymentSaving.editText?.addTextChangedListener(object : TextWatcher {\r\n                override fun afterTextChanged(s: Editable?) {\r\n                    // 상품 가격\r\n                    val productCost =\r\n                        textViewProductTotalPrice.text.toString().replace(\"원\", \"\").replace(\",\",\"\").toInt()\r\n                    val userReward = userModel?.customerUserReward ?: -1 // 보유 리워드 (없으면 0)\r\n                    val inputText = s.toString()\r\n\r\n                    // 입력값이 숫자인지 확인 후 비교\r\n                    val inputValue = inputText.toIntOrNull() ?: 0\r\n\r\n                    // 상품 가격의 20% 계산 (한도)\r\n                    val maxRewardLimit = (productCost * 0.2).toInt()\r\n                    val rewardLimit = minOf(userReward, maxRewardLimit) // 적립금 사용 한도\r\n\r\n                    // 0으로 시작하지 못하도록 방지 0123원은 없으니 문자길이가 2이상인데 앞글자가 0이면 0을 없애줌\r\n                    if (inputText.length > 1 && inputText[0] == '0') {\r\n                        val newText = inputText.toIntOrNull()?.toString() ?: \"0\"\r\n                        textInputLayoutUserPaymentSaving.editText?.setText(newText)\r\n                        // 커서를 뒤로 옮기기\r\n                        textInputLayoutUserPaymentSaving.editText?.setSelection(newText.length)\r\n                    }\r\n\r\n                    if (inputText.length == 0) {\r\n                        val newText = inputText.toIntOrNull()?.toString() ?: \"0\"\r\n                        textInputLayoutUserPaymentSaving.editText?.setText(newText)\r\n                        // 커서를 뒤로 옮기기\r\n                        textInputLayoutUserPaymentSaving.editText?.setSelection(newText.length)\r\n                    }\r\n\r\n                    if (inputValue > rewardLimit) {\r\n                        // 보유 리워드보다 크면 자동으로 보유 리워드 값으로 설정\r\n                        textInputLayoutUserPaymentSaving.editText?.setText(rewardLimit.toString())\r\n                        // 커서를 뒤로 옮기기\r\n                        textInputLayoutUserPaymentSaving.editText?.setSelection(rewardLimit.toString().length)\r\n                    }\r\n\r\n\r\n                    if (inputText.isNotEmpty()) {\r\n                        // 값을 변경할때 값과 보유 리워드와 같으면 발생하는 리스너\r\n                        if (inputText.toInt() >= rewardLimit) {\r\n                            checkboxUserPaymentUseSavingAll.isChecked = true\r\n                        } else {\r\n                            // 전체 체크 상태에서 값을 변경할때 발생하는 리스너\r\n                            checkboxUserPaymentUseSavingAll.isChecked = false\r\n\r\n                        }\r\n\r\n                        // 적립금 사용금 표시 메서드 호출\r\n                        settingViewReward()\r\n                        // 총 결제 금액 표시\r\n                        settingViewTotalCost()\r\n                    }\r\n                }\r\n\r\n                override fun beforeTextChanged(\r\n                    s: CharSequence?,\r\n                    start: Int,\r\n                    count: Int,\r\n                    after: Int\r\n                ) {\r\n                }\r\n\r\n                override fun onTextChanged(s: CharSequence?, start: Int, before: Int, count: Int) {}\r\n            })\r\n        }\r\n    }\r\n\r\n    // 배송비 설정\r\n    fun settingViewDeliverCost() {\r\n        // 장바구니 루트로 온 경우\r\n        if (args.fromWhere == \"Cart\") {\r\n            // 장바구니에 있는 물건들 총 가격 구매 여부가 true인것들 합계 구하기\r\n            CoroutineScope(Dispatchers.Main).launch {\r\n                val work1 = async(Dispatchers.IO) {\r\n                    CartProductService.gettingMyCartProductCheckedItems(homeActivity.userCartDocId)\r\n                }\r\n                val checkedList = work1.await()\r\n                var sumPrice = 0\r\n                checkedList.forEach { sumPrice += it.cartProductPrice }\r\n\r\n                if (sumPrice >= 50000) {\r\n                    binding.textViewUserPaymentDeliveryCharge.text = \"0원\"\r\n                } else {\r\n                    binding.textViewUserPaymentDeliveryCharge.text = \"3,000원\"\r\n                }\r\n            }\r\n        } else {\r\n            // 상품에서 바로 구매한 경우\r\n            CoroutineScope(Dispatchers.Main).launch {\r\n                val work1 = async(Dispatchers.IO) {\r\n                    ProductService.gettingProductOneByDocId(args.productDocIdDirectPurchase!!)\r\n                }\r\n                val product = work1.await()\r\n                val productCost = product.productPrice * args.productCountDirectPurchase\r\n                if (productCost >= 50000) {\r\n                    binding.textViewUserPaymentDeliveryCharge.text = \"0원\"\r\n                } else {\r\n\r\n                    binding.textViewUserPaymentDeliveryCharge.text = \"3,000원\"\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // 보유 적립금 설정\r\n    fun settingViewMyReward() {\r\n        CoroutineScope(Dispatchers.Main).launch {\r\n            while (userModel == null) {\r\n                delay(500) // 500ms 대기 후 다시 확인\r\n            }\r\n\r\n            // userModel이 null이 아니면 UI 업데이트\r\n            binding.apply {\r\n                textViewUserPaymentRequestPresentSaving.text =\r\n                    \"보유 적립금 : ${(userModel?.customerUserReward ?: -1).convertThreeDigitComma()}\"\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    // 적립금 사용금 표시\r\n    fun settingViewReward() {\r\n        CoroutineScope(Dispatchers.Main).launch {\r\n            delay(0)\r\n            binding.apply {\r\n                textViewUserPaymentTotalSavingInfo.text =\r\n                    \"${textInputLayoutUserPaymentSaving.editText?.text.toString().toInt().convertThreeDigitComma()}\"\r\n            }\r\n        }\r\n    }\r\n\r\n    // 상품 가격 표시\r\n    fun settingViewProductsPrice() {\r\n        when (args.fromWhere) {\r\n            \"Cart\" -> {\r\n                CoroutineScope(Dispatchers.Main).launch {\r\n                    val work1 = async(Dispatchers.IO) {\r\n                        CartProductService.gettingMyCartProductCheckedItems(homeActivity.userCartDocId)\r\n                    }\r\n                    val checkedList = work1.await()\r\n                    var sumPrice = 0\r\n                    checkedList.forEach {\r\n                        sumPrice += it.cartProductPrice\r\n                    }\r\n\r\n                    binding.apply {\r\n                        textViewProductTotalPrice.text = \"${sumPrice.convertThreeDigitComma()}\"\r\n                    }\r\n                }\r\n            }\r\n\r\n            else -> {\r\n                CoroutineScope(Dispatchers.Main).launch {\r\n                    val work1 = async(Dispatchers.IO) {\r\n                        ProductService.gettingProductOneByDocId(args.productDocIdDirectPurchase!!)\r\n                    }\r\n                    val productModel = work1.await()\r\n                    val sumPrice = productModel.productPrice * args.productCountDirectPurchase\r\n\r\n                    binding.apply {\r\n                        textViewProductTotalPrice.text = \"${sumPrice.convertThreeDigitComma()}\"\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n    // 총 결제 금액 표시\r\n    fun settingViewTotalCost() {\r\n        CoroutineScope(Dispatchers.Main).launch {\r\n            delay(300)\r\n            binding.apply {\r\n                // 상품 가격\r\n                val productPrice =\r\n                    textViewProductTotalPrice.text.toString().replace(\"원\", \"\").replace(\",\",\"\").trim().toIntOrNull()\r\n                        ?: 0\r\n\r\n                // 적립금\r\n                val usedReward =\r\n                    textViewUserPaymentTotalSavingInfo.text.toString().replace(\"원\", \"\").replace(\",\",\"\").trim()\r\n                        .toIntOrNull() ?: 0\r\n\r\n                // 배송비\r\n                val shipmentCost =\r\n                    textViewUserPaymentDeliveryCharge.text.toString().replace(\"원\", \"\").replace(\",\",\"\").trim()\r\n                        .toIntOrNull() ?: 0\r\n\r\n                val totalCost = productPrice + shipmentCost - usedReward\r\n                textViewUserPaymentTotalPayment.text = \"${totalCost.convertThreeDigitComma()}\"\r\n            }\r\n        }\r\n    }\r\n\r\n    // 주문 완료 버튼 클릭 시 처리\r\n    fun onClickButtonButtonUserCartOrder() {\r\n        binding.buttonUserCartOrder.setOnClickListener {\r\n            CoroutineScope(Dispatchers.Main).launch {\r\n                // 주문 성공 여부 변수\r\n                var result = true\r\n                // 1. 배송 정보 추가\r\n                val deliveryDocId = addDelivery()\r\n\r\n                // 2. 주문 추가 (배송 문서 ID 전달)\r\n                val orderDocId = addOrder(deliveryDocId)\r\n\r\n                // 장바구니에서 주문화면으로 도달한 경우\r\n                result = if (args.fromWhere == \"Cart\") {\r\n                    // 3. 주문 상품 추가 (주문 문서 ID 전달)\r\n                    addOrderProduct(orderDocId)\r\n                } else {\r\n                    // 상품 정보에서 바로 구매하러 온 경우\r\n                    addOrderProductWhenDirectPurchase(orderDocId)\r\n                }\r\n                // 4. 결과에 따라 주소 변경\r\n                if (result) {\r\n                    if (binding.checkboxUserPaymentDefaultAddress.isChecked) {\r\n                        // 기본 배송지로 설정을 체크했다면\r\n                        changeBasicDeliverAddress()\r\n                    }\r\n                    // 5. 주문 후 장바구니에서 구매했던 품목은 삭제처리하기\r\n                    deleteCartProductAfterPurchase()\r\n                    // 사용자 적립금 차감 메서드 호출\r\n                    updateUserReward()\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    // 배송 문서 생성\r\n    suspend fun addDelivery(): String {\r\n        return withContext(Dispatchers.IO) {\r\n            // IO 디스패처에서 백그라운드 작업 수행\r\n            val result: String\r\n            val addDeliveryModel = DeliveryModel()\r\n\r\n            withContext(Dispatchers.Main) {\r\n                binding.apply {\r\n                    // 배송 방식 받아오기\r\n                    val deliverOption =\r\n                        when (radioGroupUserPaymentDeliveryMethod.checkedRadioButtonId) {\r\n                            R.id.buttonUserPaymentDeliveryMethodDoor -> DeliveryOption.DOOR_DELIVERY // 문앞 배송\r\n                            R.id.buttonUserPaymentDeliveryMethodBox -> DeliveryOption.PARCEL_LOCKER // 택배 보관함\r\n                            R.id.buttonUserPaymentDeliveryMethodOffice -> DeliveryOption.SECURITY_OFFICE // 보안실 배송\r\n                            else -> DeliveryOption.DOOR_DELIVERY // 기본값: 문앞 배송\r\n                        }\r\n\r\n                    // 배송지 문서 ID 설정\r\n                    addDeliveryModel.deliveryAddressDocId =\r\n                        deliveryAddressSpot?.deliveryAddressDocId ?: \"null\"\r\n\r\n                    // 배송 방식 설정\r\n                    addDeliveryModel.deliveryOption = deliverOption\r\n\r\n                    // 기타 요청 사항 입력값 받기\r\n                    addDeliveryModel.deliveryEtc =\r\n                        textInputLayoutUserPaymentRequest.editText?.text.toString()\r\n                }\r\n            }\r\n\r\n            // 배송 서비스 호출\r\n            result = DeliveryService.addUserDelivery(addDeliveryModel)\r\n\r\n            // 배송 DocId 리턴\r\n            result\r\n        }\r\n    }\r\n\r\n\r\n    // 주문 넣기 메서드\r\n    suspend fun addOrder(addDeliverDocId: String): String {\r\n        return withContext(Dispatchers.IO) {\r\n            // IO 디스패처에서 백그라운드 작업 수행\r\n            val result: String\r\n            val addOrderModel = OrderModel()\r\n\r\n            withContext(Dispatchers.Main) {\r\n                binding.apply {\r\n\r\n                    addOrderModel.orderCustomerDocId = homeActivity.loginUserDocumentId\r\n\r\n                    // 배송 DocID\r\n                    addOrderModel.deliverDocId = addDeliverDocId\r\n\r\n                    // 배송비\r\n                    addOrderModel.orderDeliveryCost =\r\n                        textViewUserPaymentDeliveryCharge.text.toString().replace(\"원\", \"\")\r\n                            .toInt()\r\n                    // 적립금 사용액\r\n                    addOrderModel.usedReward =if(textViewUserPaymentTotalSavingInfo.text.toString() ==\"\"){0}else{\r\n                            textViewUserPaymentTotalSavingInfo.text.toString().replace(\"원\", \"\")\r\n                                .toInt()\r\n                        }\r\n                    // 결제 방식\r\n                    addOrderModel.orderPaymentOption = when (paymentOptionState) {\r\n                        OrderPaymentOption.ORDER_PAYMENT_OPTION_ACCOUNT -> OrderPaymentOption.ORDER_PAYMENT_OPTION_ACCOUNT\r\n                        OrderPaymentOption.ORDER_PAYMENT_OPTION_CARD -> OrderPaymentOption.ORDER_PAYMENT_OPTION_CARD\r\n                        OrderPaymentOption.ORDER_PAYMENT_OPTION_KAKAO_PAY -> OrderPaymentOption.ORDER_PAYMENT_OPTION_KAKAO_PAY\r\n                        OrderPaymentOption.ORDER_PAYMENT_OPTION_NAVER_PAY -> OrderPaymentOption.ORDER_PAYMENT_OPTION_NAVER_PAY\r\n                    }\r\n\r\n                    // 주문 추가 서비스 호출\r\n                    result = OrderService.addMyOrder(addOrderModel)\r\n                }\r\n            }\r\n            result // orderDocId 문자열 반환\r\n        }\r\n    }\r\n\r\n    suspend fun addOrderProduct(addOrderId: String): Boolean {\r\n        val orderProductList = mutableListOf<OrderProductModel>()\r\n        val cartProductList =\r\n            CartProductService.gettingMyCartProductCheckedItems(homeActivity.userCartDocId)\r\n\r\n        binding.apply {\r\n            cartProductList.forEach {\r\n                val orderProductModel = OrderProductModel()\r\n                // order ID\r\n                orderProductModel.orderId = addOrderId\r\n                // 주문상품 이름\r\n                orderProductModel.orderProductName = it.cartProductName\r\n                // 주문상품 수량\r\n                orderProductModel.orderProductCount = it.cartItemProductQuantity\r\n                // 주문상품 예정일\r\n                orderProductModel.orderDeliveryDueDate = it.cartItemDeliveryDueDate\r\n                // 주문상품 문서 ID 수정 hj orderProductDocId -> productDocId 수정함\r\n                orderProductModel.productDocId = it.cartItemProductDocId\r\n                // 주문상품 이미지 받아오기\r\n                val productModel: ProductModel =\r\n                    ProductService.gettingProductOneByDocId(it.cartItemProductDocId)\r\n                val imgPath = productModel.productImages[0]\r\n                // 주문상품 이미지 설정\r\n                orderProductModel.orderProductImagePath = imgPath\r\n                // 주문상품 단가\r\n                orderProductModel.orderProductPrice = it.cartProductUnitPrice\r\n                // 주문상품 가격\r\n                orderProductModel.orderProductTotalPrice = it.cartProductPrice\r\n                // 구독상품\r\n                orderProductModel.deliveryIsSubscribed = it.cartItemIsSubscribed\r\n                orderProductList.add(orderProductModel)\r\n            }\r\n\r\n            // 주문 상품 추가 서비스 호출\r\n            val result = OrderProductService.addOrderProduct(addOrderId, orderProductList)\r\n\r\n            // 반환 값에 따라 처리 (예: 성공시 true, 실패시 false)\r\n            return result // 이 부분은 OrderProductService의 반환 값을 기반으로 true/false 반환\r\n        }\r\n    }\r\n\r\n    // 주문 후 장바구니에서 구매품목 삭제\r\n    fun deleteCartProductAfterPurchase() {\r\n        Log.d(\"test100\", \"UserPaymentScreenFragment -> deleteCartProductAfterPurchase()\")\r\n\r\n        CoroutineScope(Dispatchers.IO).launch {\r\n            val list: MutableList<CartProductModel> = withContext(Dispatchers.IO) {\r\n                CartProductService.gettingMyCartProductCheckedItems(homeActivity.userCartDocId)\r\n            }\r\n\r\n            if (list.isEmpty()) {\r\n                Log.d(\"test100\", \"UserPaymentScreenFragment -> checked == true 인 품목 없음.\")\r\n                return@launch\r\n            }\r\n\r\n            val deleteList = mutableListOf<String>()\r\n            list.forEach {\r\n                deleteList.add(it.cartProductDocId)\r\n            }\r\n\r\n            // 구매 품목 장바구니에서 제거\r\n            CartProductService.deleteCartProducts(homeActivity.userCartDocId, deleteList)\r\n        }\r\n    }\r\n\r\n    // 사용자 적립금 관련 메서드\r\n    fun updateUserReward() {\r\n        CoroutineScope(Dispatchers.Main).launch {\r\n            withContext(Dispatchers.IO) {\r\n                val userModel = UserService.getUserInfo(homeActivity.loginUserDocumentId)[0]\r\n                var usedReward = 0\r\n                var leftReward = userModel.customerUserReward\r\n\r\n                val rewardInputText =\r\n                    binding.textInputLayoutUserPaymentSaving.editText?.text?.toString()\r\n                if (!rewardInputText.isNullOrEmpty()) {\r\n                    usedReward = rewardInputText.toInt()\r\n                    leftReward -= usedReward\r\n                }\r\n\r\n                // 사용 적립금 차감\r\n                userModel.customerUserReward = leftReward\r\n                UserService.updateUserData(userModel)\r\n\r\n                // 물건 가격의 1퍼센트 적립\r\n                val productCost = binding.textViewProductTotalPrice.text.toString().replace(\"원\",\"\").toInt()\r\n                val getReward = (productCost *0.01).toInt()\r\n\r\n                userModel.customerUserReward += getReward\r\n                UserService.updateUserData(userModel)\r\n            }\r\n        }\r\n    }\r\n\r\n    suspend fun addOrderProductWhenDirectPurchase(addOrderId: String): Boolean {\r\n        // 상품 정보 가져오기 (비동기)\r\n        val product = withContext(Dispatchers.IO) {\r\n            ProductService.gettingProductOneByDocId(args.productDocIdDirectPurchase ?: \"\")\r\n        }\r\n\r\n        val dueDateTimeStamp = convertToTimestamp(args.dueDateDirectPurchase ?: \"2024-01-01\")\r\n\r\n        // 주문상품 모델 설정\r\n        val orderProductModel = OrderProductModel().apply {\r\n            // order ID\r\n            orderId = addOrderId\r\n            // 주문상품 이름\r\n            orderProductName = product.productName\r\n            // 주문상품 수량\r\n            orderProductCount = args.productCountDirectPurchase\r\n            // 주문상품 예정일\r\n            orderDeliveryDueDate = dueDateTimeStamp\r\n            // 주문상품 문서 ID 수정 hj orderProductDocId -> productDocId 수정함\r\n            productDocId = product.productDocId\r\n            // 주문상품 이미지 받아오기\r\n            val imgPath = product.productImages[0]\r\n            // 주문상품 이미지 설정\r\n            orderProductImagePath = imgPath\r\n            // 주문상품 단가\r\n            orderProductPrice = product.productPrice\r\n            // 주문상품 가격\r\n            orderProductTotalPrice = product.productPrice * args.productCountDirectPurchase\r\n            // 구독상품\r\n            deliveryIsSubscribed = args.deliverySubscribeStateDirectPurchase\r\n        }\r\n\r\n        // 주문 상품 목록에 추가\r\n        val orderProductList = mutableListOf(orderProductModel)\r\n\r\n        // 주문 상품 추가 서비스 호출\r\n        val result = OrderProductService.addOrderProduct(addOrderId, orderProductList)\r\n\r\n        // 결과 반환\r\n        return result // 이 부분은 OrderProductService의 반환 값을 기반으로 true/false 반환\r\n    }\r\n\r\n\r\n    // 날짜 타입 변경 String-> Timestamp\r\n    // DB에 넣을때 오후 12시로 넣기위해, kst(한국시간 오후 12시) -> utc(세계기준시간 으로 변환)\r\n    // 시간 기준이 달라서 31일을 저장해도 30일로 저장되는 문제를 해결\r\n    // 아마 00시면 분단위로 짤려서 날짜가 조정됨 그래서 안전하게 오후 12시로 저장함\r\n    fun convertToTimestamp(dueDate: String): Timestamp {\r\n        // 날짜 포맷터 생성\r\n        val dateFormatter = SimpleDateFormat(\"yyyy-MM-dd\", Locale.KOREAN)\r\n        dateFormatter.timeZone = TimeZone.getTimeZone(\"Asia/Seoul\")\r\n\r\n        return try {\r\n            // 문자열을 Date 객체로 변환\r\n            val parsedDate = dateFormatter.parse(dueDate)\r\n\r\n            if (parsedDate != null) {\r\n                // 시간을 오후 12시(정오)로 설정\r\n                val calendar = Calendar.getInstance(TimeZone.getTimeZone(\"Asia/Seoul\"))\r\n                calendar.time = parsedDate\r\n                calendar.set(Calendar.HOUR_OF_DAY, 12)\r\n                calendar.set(Calendar.MINUTE, 0)\r\n                calendar.set(Calendar.SECOND, 0)\r\n                calendar.set(Calendar.MILLISECOND, 0)\r\n\r\n                // 변경된 시간을 UTC로 변환하여 Timestamp 객체 생성\r\n                val utcCalendar = Calendar.getInstance(TimeZone.getTimeZone(\"UTC\"))\r\n                utcCalendar.timeInMillis = calendar.timeInMillis\r\n                Timestamp(utcCalendar.time)\r\n            } else {\r\n                Timestamp.now()  // 날짜가 잘못된 경우 현재 시간을 반환\r\n            }\r\n        } catch (e: Exception) {\r\n            e.printStackTrace()\r\n            Timestamp.now()  // 예외 발생 시 현재 시간 반환\r\n        }\r\n    }\r\n\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/example/frume/fragment/user_fragment/user_payment/UserPaymentScreenFragment.kt b/app/src/main/java/com/example/frume/fragment/user_fragment/user_payment/UserPaymentScreenFragment.kt
--- a/app/src/main/java/com/example/frume/fragment/user_fragment/user_payment/UserPaymentScreenFragment.kt	(revision 160c79a1219f7fd011726c93d0285a01746d24ef)
+++ b/app/src/main/java/com/example/frume/fragment/user_fragment/user_payment/UserPaymentScreenFragment.kt	(date 1738631007995)
@@ -791,11 +791,11 @@
 
                     // 배송비
                     addOrderModel.orderDeliveryCost =
-                        textViewUserPaymentDeliveryCharge.text.toString().replace("원", "")
+                        textViewUserPaymentDeliveryCharge.text.toString().replace("원", "").replace(",","")
                             .toInt()
                     // 적립금 사용액
                     addOrderModel.usedReward =if(textViewUserPaymentTotalSavingInfo.text.toString() ==""){0}else{
-                            textViewUserPaymentTotalSavingInfo.text.toString().replace("원", "")
+                            textViewUserPaymentTotalSavingInfo.text.toString().replace("원", "").replace(",","")
                                 .toInt()
                         }
                     // 결제 방식
@@ -899,7 +899,7 @@
                 UserService.updateUserData(userModel)
 
                 // 물건 가격의 1퍼센트 적립
-                val productCost = binding.textViewProductTotalPrice.text.toString().replace("원","").toInt()
+                val productCost = binding.textViewProductTotalPrice.text.toString().replace("원","").replace(",","").toInt()
                 val getReward = (productCost *0.01).toInt()
 
                 userModel.customerUserReward += getReward
Index: app/src/main/res/layout/fragment_user_product_info_review.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n<layout xmlns:android=\"http://schemas.android.com/apk/res/android\"\r\n\txmlns:app=\"http://schemas.android.com/apk/res-auto\"\r\n\txmlns:tools=\"http://schemas.android.com/tools\">\r\n\r\n\t<data>\r\n\r\n\t</data>\r\n\r\n\t<androidx.constraintlayout.widget.ConstraintLayout\r\n\t\tandroid:layout_width=\"match_parent\"\r\n\t\tandroid:layout_height=\"match_parent\"\r\n\t\ttools:context=\".fragment.user_fragment.product_info.UserProductInfoReviewFragment\">\r\n\r\n\t\t<androidx.appcompat.widget.AppCompatButton\r\n\t\t\tandroid:id=\"@+id/buttonUserProductInfoReview\"\r\n\t\t\tstyle=\"@style/CustomButtonStyle\"\r\n\t\t\tandroid:layout_width=\"0dp\"\r\n\t\t\tandroid:layout_height=\"wrap_content\"\r\n\t\t\tandroid:layout_marginHorizontal=\"20dp\"\r\n\t\t\tandroid:layout_marginTop=\"20dp\"\r\n\t\t\tandroid:text=\"후기 작성\"\r\n\t\t\tapp:layout_constraintEnd_toEndOf=\"parent\"\r\n\t\t\tapp:layout_constraintStart_toStartOf=\"parent\"\r\n\t\t\tapp:layout_constraintTop_toTopOf=\"parent\" />\r\n\r\n\r\n\t\t<androidx.recyclerview.widget.RecyclerView\r\n\t\t\tandroid:id=\"@+id/recyclerViewUserProductInfoReview\"\r\n\t\t\tandroid:layout_width=\"0dp\"\r\n\t\t\tandroid:layout_height=\"0dp\"\r\n\t\t\tandroid:layout_marginBottom=\"20dp\"\r\n\t\t\tapp:layoutManager=\"androidx.recyclerview.widget.LinearLayoutManager\"\r\n\t\t\tapp:layout_constraintBottom_toTopOf=\"@id/textViewPageDivider\"\r\n\t\t\tapp:layout_constraintEnd_toEndOf=\"parent\"\r\n\t\t\tapp:layout_constraintStart_toStartOf=\"parent\"\r\n\t\t\tapp:layout_constraintTop_toBottomOf=\"@id/buttonUserProductInfoReview\"\r\n\t\t\ttools:listitem=\"@layout/item_review\" />\r\n\r\n\t\t<ImageView\r\n\t\t\tandroid:id=\"@+id/imageViewUserProductInfoReviewBack\"\r\n\t\t\tandroid:layout_width=\"wrap_content\"\r\n\t\t\tandroid:layout_height=\"wrap_content\"\r\n\t\t\tandroid:layout_marginEnd=\"20dp\"\r\n\t\t\tandroid:src=\"@drawable/ic_back_ios\"\r\n\t\t\tapp:layout_constraintBottom_toBottomOf=\"@id/textViewPageDivider\"\r\n\t\t\tapp:layout_constraintEnd_toStartOf=\"@id/textViewUserProductInfoReviewNowPageNumber\"\r\n\t\t\tapp:layout_constraintTop_toTopOf=\"@id/textViewPageDivider\" />\r\n\r\n\t\t<TextView\r\n\t\t\tandroid:id=\"@+id/textViewUserProductInfoReviewNowPageNumber\"\r\n\t\t\tandroid:layout_width=\"wrap_content\"\r\n\t\t\tandroid:layout_height=\"wrap_content\"\r\n\t\t\tandroid:layout_marginEnd=\"20dp\"\r\n\t\t\tandroid:fontFamily=\"@font/nanumsquareneo_3\"\r\n\t\t\tandroid:textSize=\"17sp\"\r\n\t\t\tapp:layout_constraintBottom_toBottomOf=\"@id/textViewPageDivider\"\r\n\t\t\tapp:layout_constraintEnd_toStartOf=\"@id/textViewPageDivider\"\r\n\t\t\tapp:layout_constraintTop_toTopOf=\"@id/textViewPageDivider\"\r\n\t\t\ttools:text=\"1\" />\r\n\r\n\t\t<TextView\r\n\t\t\tandroid:id=\"@+id/textViewPageDivider\"\r\n\t\t\tandroid:layout_width=\"wrap_content\"\r\n\t\t\tandroid:layout_height=\"wrap_content\"\r\n\t\t\tandroid:layout_marginBottom=\"30dp\"\r\n\t\t\tandroid:fontFamily=\"@font/nanumsquareneo_3\"\r\n\t\t\tandroid:text=\"/\"\r\n\t\t\tandroid:textSize=\"17sp\"\r\n\t\t\tapp:layout_constraintBottom_toBottomOf=\"parent\"\r\n\t\t\tapp:layout_constraintEnd_toEndOf=\"parent\"\r\n\t\t\tapp:layout_constraintStart_toStartOf=\"parent\" />\r\n\r\n\t\t<TextView\r\n\t\t\tandroid:id=\"@+id/textViewUserProductInfoReviewMaxPageNumber\"\r\n\t\t\tandroid:layout_width=\"wrap_content\"\r\n\t\t\tandroid:layout_height=\"wrap_content\"\r\n\t\t\tandroid:layout_marginStart=\"20dp\"\r\n\t\t\tandroid:fontFamily=\"@font/nanumsquareneo_3\"\r\n\t\t\tandroid:textSize=\"17sp\"\r\n\t\t\tapp:layout_constraintBottom_toBottomOf=\"@id/textViewPageDivider\"\r\n\t\t\tapp:layout_constraintStart_toEndOf=\"@id/textViewPageDivider\"\r\n\t\t\tapp:layout_constraintTop_toTopOf=\"@id/textViewPageDivider\"\r\n\t\t\ttools:text=\"10\" />\r\n\r\n\t\t<ImageView\r\n\t\t\tandroid:id=\"@+id/imageViewUserProductInfoReviewForward\"\r\n\t\t\tandroid:layout_width=\"wrap_content\"\r\n\t\t\tandroid:layout_height=\"wrap_content\"\r\n\t\t\tandroid:layout_marginStart=\"20dp\"\r\n\t\t\tandroid:src=\"@drawable/ic_forward_ios\"\r\n\t\t\tapp:layout_constraintBottom_toBottomOf=\"@id/textViewPageDivider\"\r\n\t\t\tapp:layout_constraintStart_toEndOf=\"@id/textViewUserProductInfoReviewMaxPageNumber\"\r\n\t\t\tapp:layout_constraintTop_toTopOf=\"@id/textViewPageDivider\" />\r\n\r\n\t</androidx.constraintlayout.widget.ConstraintLayout>\r\n</layout>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/res/layout/fragment_user_product_info_review.xml b/app/src/main/res/layout/fragment_user_product_info_review.xml
--- a/app/src/main/res/layout/fragment_user_product_info_review.xml	(revision 160c79a1219f7fd011726c93d0285a01746d24ef)
+++ b/app/src/main/res/layout/fragment_user_product_info_review.xml	(date 1738631008004)
@@ -22,7 +22,9 @@
 			android:text="후기 작성"
 			app:layout_constraintEnd_toEndOf="parent"
 			app:layout_constraintStart_toStartOf="parent"
-			app:layout_constraintTop_toTopOf="parent" />
+			app:layout_constraintTop_toTopOf="parent"
+			android:visibility="gone"
+			/>
 
 
 		<androidx.recyclerview.widget.RecyclerView
